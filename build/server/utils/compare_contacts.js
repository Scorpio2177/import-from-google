// Generated by CoffeeScript 1.8.0
var CC, ContactHelper, compareN, diacritics, hasField, _extend, _union;

diacritics = require('./diacritics');

ContactHelper = require('./contact_helper');

module.exports = CC = {};

CC.isSamePerson = function(contact1, contact2) {
  return contact1.fn === contact2.fn && contact1.datapoints.some(function(field) {
    var _ref;
    if ((_ref = field.name) === 'tel' || _ref === 'adr' || _ref === 'email' || _ref === 'chat') {
      return hasField(field, contact2);
    } else {
      return false;
    }
  });
};

CC.mayBeSamePerson = function(contact1, contact2) {
  return compareN(contact1.n, contact2.n) > 0;
};

CC.findSimilars = function(contacts) {
  var contact, contact2, similar, similars, viewed, _i, _j, _len, _len1;
  viewed = {};
  similars = [];
  for (_i = 0, _len = contacts.length; _i < _len; _i++) {
    contact = contacts[_i];
    viewed[contact._id] = true;
    similar = [contact];
    for (_j = 0, _len1 = contacts.length; _j < _len1; _j++) {
      contact2 = contacts[_j];
      if (!(contact2._id in viewed) && CC.mayBeSamePerson(contact, contact2)) {
        viewed[contact2._id] = true;
        similar.push(contact2);
      }
    }
    if (similar.length > 1) {
      similars.push(similar);
    }
  }
  return similars;
};

CC.mergeContacts = function(base, toMerge) {
  toMerge.datapoints.forEach(function(field) {
    if (!hasField(field, base, true)) {
      return base.datapoints.push(field);
    }
  });
  delete toMerge.datapoints;
  if (toMerge.accounts != null) {
    toMerge.accounts.forEach(function(account) {
      if (!ContactHelper.hasAccount(base, account.type, account.name)) {
        return ContactHelper.setAccount(base, account);
      }
    });
    delete toMerge.accounts;
  }
  base.tags = _union(base.tags, toMerge.tags);
  delete toMerge.tags;
  if ((toMerge.note != null) && toMerge.note !== '' && (base.note != null) && base.note !== '') {
    base.note += "\n" + toMerge.note;
  }
  delete toMerge.note;
  base = _extend(base, toMerge);
  return base;
};

compareN = function(n1, n2) {
  var dummy, firstName1, firstName2, lastName1, lastName2, simplify, _ref, _ref1;
  _ref = n1.split(';'), lastName1 = _ref[0], firstName1 = _ref[1], dummy = _ref[2], dummy = _ref[3], dummy = _ref[4];
  _ref1 = n2.split(';'), lastName2 = _ref1[0], firstName2 = _ref1[1], dummy = _ref1[2], dummy = _ref1[3], dummy = _ref1[4];
  simplify = function(s) {
    s = diacritics.asciize(s);
    return s.toLowerCase();
  };
  lastName1 = simplify(lastName1);
  firstName1 = simplify(firstName1);
  lastName2 = simplify(lastName2);
  firstName2 = simplify(firstName2);
  if ((lastName1 !== '' || firstName1 !== '') && (lastName2 !== '' || firstName2 !== '') && (lastName1 === lastName2 && firstName1 === firstName2 || lastName1 === firstName2 && firstName1 === lastName2)) {
    return 1;
  } else {
    return -1;
  }
};

hasField = function(field, contact, checkType) {
  if (checkType == null) {
    checkType = false;
  }
  if (field.value == null) {
    return false;
  }
  return contact.datapoints.some(function(baseField) {
    var i, same, _ref;
    if (field.name === baseField.name && (!checkType || checkType && field.type === baseField.type) && (baseField.value != null)) {
      if (field.name === 'tel') {
        return field.value.replace(/[-\s]/g, '') === baseField.value.replace(/[-\s]/g, '');
      } else if (field.name === 'adr') {
        same = true;
        i = 0;
        while (same && i < 7) {
          same = same && field.value[i] === baseField.value[i] || field.value[i] === "" && (baseField.value[i] == null) || !((_ref = field.value) != null ? _ref[i] : void 0) && baseField.value[i] === "";
          i++;
        }
        return same;
      } else {
        return field.value === baseField.value;
      }
    } else {
      return false;
    }
  });
};

_union = function(a, b) {
  a = a || [];
  b = b || [];
  return a.concat(b.filter(function(item) {
    return a.indexOf(item) < 0;
  }));
};

_extend = function(a, b) {
  var k, v;
  for (k in b) {
    v = b[k];
    if (v != null) {
      a[k] = v;
    }
  }
  return a;
};
